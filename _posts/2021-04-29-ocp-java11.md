---
layout: post
title:  'Experience Report: OCP Java SE 11 Developer Certification'
authors: ['karsten']
featuredImage: java11-omg
excerpt: "OCP Java SE 11 Developer (1Z0-819-J) is the successor of previous OCA and OCP certifications
combined in one. This article presents my personal experience report from taking the online exam, starting from preparation over study to the exam day."
categories: [Java, Certification]
header:
  text: OCP 1Z0-819-J Experience Report
  image: post
---

On April 23rd, 2021 I successfully finished the [OCP Java 11 Developer (1Z0-819-J) certification](https://catalog-education.oracle.com/pls/certview/sharebadge?id=234B6B4A4DE7F3335C09A32A446472C1C822292C0E86A13D41919E2966EE04DE). Oracle released this new certification in October 2020 as a successor of both Java SE 11 Programmer I (1Z0-815) and Java SE 11 Programmer II (1Z0-816) combined in one certification.

It was an intensive experience and I want to share my experiences about the motivation, preparation, and the exam itself. The opinions expressed in this text are mine and thus subjective. Nevertheless, I hope you find some inspirations and tips for your journey to get the certification.

## Why do the Java certification?

I’m working with Java since my study time which is 25 years ago. I first got in contact with Java version 1.0. At that time, I was mainly using it to develop small applets and for studying computer languages. Since I started as a consultant in 2000, I am using Java as my main language every day.

I never considered a Java certification as necessary to work successfully on complex Java-based systems. In my personal opinion, it doesn't make much difference whether I have a certificate or not. I'm convinced that even non-IT staff will immediately realize my rock-solid Java background when taking a short glimpse at my CV. So why should I study all these basic details again?

It all began with an initiative from a colleague of mine at [Karakun](https://www.karakun.com). He made us aware of Oracle offering the OCP Java 11 Developer exam for just 25 USD when taking the exam before April 25th, 2021. This [special offer came along with Java's 25th anniversary](https://blogs.oracle.com/oracleuniversity/java-25-anniversary). 

He and many others at Karakun already enjoyed a certification for older Java versions. However, no one did the Java 11 certification so far  - although we are all working in a Java-centric engineering and consulting company. And as we all know, Java did evolve quite a bit in recent years. 

So, he asked around who would be interested in joining a working group to do the certification together. And it was nice to see that even some of our newer colleagues joined the working group. The motivation for the group members was to dig deeper into the more recent features which are not all in use in our daily work. The goal was not just to pass the exam but rather to push each other to learn something useful and, of course, to get this certification. 

## The study phase

We started end of February and decided to learn either reading the [OCP Oracle Certified Professional Java SE 11 Developer Complete Study Guide by Jeanne Boyarsky and Scott Selikoff](https://www.selikoff.net/ocp11-complete/) or watching the Oracle video tutorials. While the book has 1300 pages, the videos have a total length of 33 hours. Quite a bunch! 

Together we set up this study plan for the book:

<figure class="wp-block-table"><table><thead><tr><th scope="col">Week</th><th scope="col">Dates</th><th scope="col">Chapters</th><th scope="col">Num pages</th></tr></thead><tbody><tr><td>11</td><td>15-21 March</td><td>1 Welcome to Java<br>2 Java Building Blocks<br>3 Operators<br>4 Making Decisions<br>5 Core Java APIs</td><td>~220</td></tr><tr><td>12</td><td>22-28 March</td><td>6 Lambdas and Functional Interfaces<br>7 Methods and Encapsulation<br>8 Class Design<br>9 Advanced Class Design</td><td>~180</td></tr><tr><td>13</td><td>29-4 April</td><td>10 Exceptions<br>11 Modules<br>12 Java Fundamentals<br>13 Annotations</td><td>~200</td></tr><tr><td>14</td><td>5-11 April</td><td>14 Generics and Collections<br>15 Functional Programming<br>16 Exceptions, Assertions, and Localization</td><td>~200</td></tr><tr><td>15</td><td>12-18 April</td><td>17 Modular Applications<br>18 Concurrency<br>19 I/O<br>20 NIO.2</td><td>~220</td></tr><tr><td>16</td><td>19-25 April</td><td>21 JDBC<br>22 Security</td><td>~100</td></tr></tbody></table></figure>

At Karakun, every employee has a personal education budget that can be freely used. This budget covers the costs and the (missed working) time. But preparing for such an exam also demands a high amount of spare time. As all group members were quite busy with their daily projects and customers always come first, it sometimes wasn't possible to stick to this structure.

At that time, I was strongly busy with a customer project. It demanded almost all of my time and there was practically no freedom to get started. It didn't take long until I was behind schedule and started to think that I won't make it in time. 

Then came the Easter break. And “thanks” to the corona crisis and some bad weather, there was suddenly some spare time. Thus, I decided to study for the exam almost every day during my vacations. I normally try to avoid working during vacations and use the time to relax or spend time with my family instead. Going through the book was the opposite of relaxing and my family did not get all the attention they deserve. But that effort brought me back on track.

At the end of the vacations respectively 10 days before the exam, I completed chapter 19 of 22. There were “only” 3 chapters left to read and a ton of exam questions to practice. It all looked so good. But then I was starting a second project and the main project demanded some extra focus, too. As a result, I had to complete the preparations in the evenings and on weekends.

## What I learned from studying the book

I am quite confident in my Java skills. However, one goal of the study was to learn especially those aspects that I don't use that frequently in my daily work and also to get into details of things. Having a 1300 pages study guide and only a few findings would have meant I am either doing something tremendously great or extremely wrong.

I took my time to read the book carefully, page by page, learning the very last details. Normally, I tend to skip parts that I think I already know. But I felt it was worth reading everything. 

After the introduction part, there is the first set of assessment questions to get a feeling of where you are and what is awaiting you in the exam. I considered them harder to answer than expected. I failed many of them. Suddenly I knew that I have to prepare better to pass the exam.

All questions are multiple-choice with one or more correct options. Of course, the book doesn't tell you the number of correct options for each question. In the exam, you always know how many answers you have to check. Doing the review questions after each chapter, I still made many mistakes. I often selected one too many or one too few answers.

For every incorrectly answered question, I read the explanation in the appendix. This helped me to understand the topic in detail and also showed me how the exam questions are trying to trick you. Of course, compilation issues are often a trick, and as the book recommends you always have to ask yourself at first “Does it compile?”. But you also learn other trick questions. After finishing the book, I went through all the incorrect answers again. I still failed some of them but the hit rate was much higher.

Overall, the Java SE 11 Developer Complete Study Guide is very well written. It covers every aspect of the exam in detail, one topic after the other without overlapping or taking anything for granted. Also, the code examples are well chosen and helpful for understanding. The writing style is very easy to follow. I can recommend reading the book!

While studying, I learned many details of Java that I'm not concerned about in my daily work. The compiler, the IDE, Dr. Google, or Mr. Stackoverflow help to correct me when I was doing something wrong. The book helped to focus on those details and think ahead.

## About certain exam topics

You’ll need to learn many details of the language and its tools. Some of them you’ll likely never need. Probably some of them shouldn't even be used. The book also tries to set these details into the context of modern-day programming. You’ll also see that it is possible to write code in Java being more complicated to understand than Perl scripts written by a drunk gorilla.

For me, especially hard to understand and follow are nested labeled loops with incrementing different scoped variables using either pre- or post-increment operator and usage of `break` or `continue`. To answer those questions correctly, you have to track the variable state step by step through the execution of the program. Although you really should understand how and when to use `break` and `continue`, doing this together with a complicated incremented variable state just makes knots in your brain. During my studies, I took the time to follow the program flow and state but for the exam, I decided to just skip such a question. It simply takes too much time, and one question is worth as many points as any other.

For the exam, you learn all the command line switches and their inconsistencies when they use a single or double hyphen. Also options for commands like `jmod`. Honestly, I didn't know this command before. So my taking was that this command exists and I roughly got its purpose. But why do you need to memorize which command-line options it offers and get tricked by options that might look right? When I need to know what option a command offers, I ask for it in a terminal. Of course, you should be aware of the most important commands and the options you most likely use. It does not make you a better programmer to know options you very rarely use.

I learned a lot on Java serialization. Actually more then I would like to. Nowadays I don't really care much about Java object serialization. The basic rules are well understood. It was quite interesting to learn the order of object initialization, i.e. which constructor is called or not and in which order. I never really cared so far. I read about options to influence what and how state is (de-) serialized which I'll never use again. However, now I know there are more options available than I was aware of before.

Of course there were also topics which I use daily, but where the book really helped me to learn and think about in detail. I especially enjoyed here the chapters about Generics, Functional Programming, Modular Applications, Concurrency and NIO.2. This really helped me to improve my hard skills.
## Mock exams

Additionally to the Study Guide I ordered the [1Z0-819-J Mock Exams from Enthuware](https://enthuware.com/java-certification-mock-exams/oracle-certified-professional/ocp-java-11-exam-1Z0-819-J).
I read about them when I was looking into some threads about the certification in the [OCP Forum at Coderanch](https://coderanch.com/f/24/java-programmer-OCPJP).
I've been in this forum to report some small possible errata in the book. In the threads, some developers were mentioning the mock exams and I thought it could be worth trying some in addition to the review questions in the book.

Before the exam, I only had time to do seven of those mock exams. There are more than 20 with ~50 questions each in total. I can only recommend using them when preparing for the exam. While it is possible to display how many answers you have to choose, the questions themselves felt partially even more tricky than in the book.

You can either review them after finishing the complete test or after each question. I started with the first option and reviewed the questions where I failed. The different options are commented on and help to understand the topic in more detail. For the last mock exams, I decided to use the option to review after every question. I also used this to better understand correct answers to make sure I got the topic. Sometimes you might be just randomly right and I wanted to avoid false positives. Of course, this took additional time.

Overall, the mock exams simulate the real exam in their content and extend quite well. You have to answer about 50 questions about all topics, just like in the exam. I did not enforce a timeframe of 90 mins like in the exam. Estimated each mock exam including reviews took 2 - 2,5h.

## Exam check-in

Finally, the exam day came. It was time to check-in. I received a mail from Pearson VUE asking me to [check the system requirements and exam policies](https://home.pearsonvue.com/oracle/onvue) a week before. For the system test, I had to download the testing software which does not allow any running programs (except for Finder on macOS). Make sure to read [Tips on taking an OnVUE exam](https://home.pearsonvue.com/onvue-tips).
Honestly, I did not do this and it would have avoided some stress. Let me tell you what went wrong for me.

I started the login procedure as recommended 30 minutes before the start. I had to start the OnVUE software and got a code from the login link in the email I received. Before, I mostly cleaned my desk except for my notebook and the external monitor I wanted to work with. Then, I had to define the camera I wanted to use. I had the notebook closed and chose the external webcam. The software showed me the camera stream, everything looked fine so far.

The next step involved using the smartphone for the check-in procedure. I had 2 options: either get a text message with a link or enter the link manually. I chose the text message but did not receive anything. The OnVUE software was waiting for the smartphone and I was blocked. I had to restart the software and then enter the link manually. Scanning a QR code would have helped a bit.

I opened the link and got additional information. One was that no external monitors are allowed. I wanted to avoid problems, unplugged it, and switched to the notebook’s display and camera. If I read the tips carefully I would have realized that external monitors are allowed when the notebook is closed. I was just confused by the message on the web page. Now, the check-in software requested to take a photo of myself, then the front and back of my identity document, and photos of my room in front of the desk, back, left, and right.

Finally, I was done and got into the waiting queue. There was a counter showing how many people already checked in. I was around position 25 and it took 5 to 10 minutes until I was the first in line.

Now, a proctor opened a chat window and wrote that he does not see my video stream. Maybe this was because I unplugged the external monitor and the webcam during the check-in procedure? However, since the software still showed me in a video stream, I was surprised that the proctor did not see it as well. I had to restart the software once again and redo the check-in procedure. The check-in involved opening the link again. Fortunately, I did not need to take the photos this time as it was already close to starting time. 

I came back into the check-in queue and was immediately told to be next. I expected that since I was already about to be checked in and just needed to restart the software. However, it took about 10 minutes until a proctor contacted me. Meanwhile, the official start time passed and I was a bit nervous as the software displayed I’m next, and literally, nothing happened.

When I got the call from the proctor she asked me to take the notebook and show it around my desk. I had to remove some more stuff from the desk and finally, the exam started.

## The exam

Now was the time. All or nothing! When I started the test, the counter began. 90 minutes for 50 questions.

The questions comprised all topics covered by the Study Guide. From data types, loops, lambdas, modular applications to security and JDBC. I was prepared for this as the mock exams simulate this quite well.

Doing the exam, you can skip questions to answer them later. When completing the last question, you have the option to answer all open questions. One tip I can give is: Do it. Decide fast if a question will take you long to understand. This can be either due to a large number of lines of code or a very complex code structure. Since each question weighs as much as the other, just risk that you’ll not answer those and get points on others. Of course, you should do this only for few questions. 

I had about 4. Already planned for skipping was the question about nested labeled loops asking where to insert `break` <LABEL> or `continue` <LABEL> to get a specific output. I encountered such a question and immediately skipped it. The time was well spent on others.

Overall, the questions were not easy and often tricky. But you know that from practicing the questions in the Study Guide and the mock exams. I had the feeling that the mock exam questions were a bit harder than the questions I had in the exam. So if you are doing well on those tests, you are well prepared!

Some questions cause compilation errors. As recommended earlier, follow the call sequence and ask yourself “Does it compile?”. I spotted some errors like data type conversion, extending/overriding final classes/methods, and reducing the visibility of overridden methods. I likely missed some and in the end, I did not get a 100% score. 

I had a moderate pace to answer the questions. I read each one with care and also the answers. Afterwards, I was often clear about which options I would answer. Sometimes, I was not completely sure and marked those questions for review after finishing.

In the end, I had less than 10 minutes left for the skipped and marked questions. That was enough to answer the skipped ones. But there was no time left to review unsure ones. For the mentioned nested loop question, I just did a wild guess and it was surely wrong.

As the time was up, the exam finished automatically and I immediately got the result and the percentage of correct answers. I was glad that I passed it and that it was all over now.

## Conclusion

Doing this exam is an intense experience and requires thorough preparation even for experienced Java developers. Being experienced, take this exam as a chance to learn details and challenge yourself. Hopefully, you are not doing the exam because you need just the badge in your CV. Don't just pass it somehow but improve your skills.

I recommend studying the [OCP Java 11 Complete Study Guide](https://www.selikoff.net/ocp11-complete/) in detail and additionally practicing the [Mock Exams](https://enthuware.com/java-certification-mock-exams/oracle-certified-professional/ocp-java-11-exam-1Z0-819-J) from Enthuware. By doing this, you are well prepared for taking the exam! 

On exam day, make sure to check in early and have nothing on your desk within arm's reach beside your computer. Take your time to read the questions and answers carefully. Follow the program flow from the main method to what is instantiated and called. 

Skip questions immediately when reading and understanding them takes too much time. You can do this for 4-6 questions during the exam. Make sure to have 10 minutes left to answer them later. For the most tricky ones just randomly check options.

However, do not underestimate the needed effort. If I wouldn’t have sacrificed a large part of my vacations and even more free time, I would have never made it through the material in time to do the exam before April 25th. I might have passed it but then I wouldn’t have read the rest of the book. 

Not everyone in our study group made it due to a lack of time besides their regular work. Those colleagues decided to take the exam later once they have finished learning, paying the regular cost. Just trying to pass was not the right thing for them.

I hope this article gave you some valuable hints for preparing for your exam. All the best!
